(int, int, int, slice) load_data() inline_ref {
	var ds = get_data().begin_parse();
	var res = (
		ds~load_uint(32),
		ds~load_uint(256),
		ds~load_grams(),
		ds~load_msg_addr()
	);
	ds.end_parse();
	return res;
}

() save_data(int seqno, int public_key, int total_locked, slice collector_addr) impure inline_ref {
	var st = begin_cell()
		.store_uint(seqno, 32)
		.store_uint(public_key, 256)
		.store_grams(total_locked)
		.store_slice(collector_addr)
		.end_cell();
	set_data(st);
}

() recv_internal(slice in_msg) impure {
  ;; do nothing for internal messages
}

() recv_external(slice in_msg) impure {
	slice signature = in_msg~load_bits(512);
	var cs = in_msg;
	int seqno = cs~load_uint(32);

	(int stored_seqno, int public_key, int total_locked, slice collector_addr) = load_data();
	throw_unless(33, seqno == stored_seqno);
	throw_unless(34, check_signature(slice_hash(in_msg), signature, public_key));

	accept_message(); ;; message is signed by owner

	int op = cs~load_uint(32);
    ifnot (op) {
		;; init contract
	}

	save_data(seqno + 1, public_key, total_locked, collector_addr);
}

;; Get methods

_ get_bridge_data() method_id {
    var (seqno, public_key, total_locked, collector_addr) = load_data();
	var (wc, addr) = parse_std_addr(collector_addr);
    return (seqno, public_key, total_locked, wc, addr);
}
