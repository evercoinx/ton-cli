(slice, (int, int, int)) load_fees(slice s) inline {
    var fees = (s~load_grams(), s~load_grams(), s~load_uint(14));
    return (s, fees);
}

(int, int, int, slice, (int, int, int)) load_data() inline_ref {
	var ds = get_data().begin_parse();
	var res = (
		ds~load_uint(32),
		ds~load_uint(256),
		ds~load_grams(),
		ds~load_msg_addr(),
		ds~load_fees()
	);
	ds.end_parse();
	return res;
}

builder store_fees(builder b, (int, int, int) fees) inline {
	var (flat_reward, network_fee, factor) = fees;
	throw_if(391, factor > 10000);

	return b.store_grams(flat_reward)
		.store_grams(network_fee)
		.store_uint(factor, 14);
}

() save_data(int seqno, int public_key, int total_locked, slice collector_addr, (int, int, int) fees) impure inline_ref {
	var st = begin_cell()
		.store_uint(seqno, 32)
		.store_uint(public_key, 256)
		.store_grams(total_locked)
		.store_slice(collector_addr)
		.store_fees(fees)
		.end_cell();
	set_data(st);
}

() recv_internal(slice in_msg) impure {
  ;; do nothing for internal messages
}

() recv_external(slice in_msg) impure {
	slice signature = in_msg~load_bits(512);
	var cs = in_msg;
	int seqno = cs~load_uint(32);

	var (stored_seqno, public_key, total_locked, collector_addr, fees) = load_data();
	throw_unless(33, seqno == stored_seqno);
	throw_unless(34, check_signature(slice_hash(in_msg), signature, public_key));

	accept_message(); ;; message is signed by owner

	int op = cs~load_uint(32);
    ifnot (op) {
		;; init contract
	}

	save_data(seqno + 1, public_key, total_locked, collector_addr, fees);
}

;; Get methods

_ get_bridge_data() method_id {
    var (seqno, public_key, total_locked, collector_addr, fees) = load_data();
	var (flat_reward, network_fee, factor) = fees;
	var (wc, addr) = parse_std_addr(collector_addr);
    return (seqno, public_key, total_locked, wc, addr, flat_reward, network_fee, factor);
}
