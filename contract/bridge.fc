(slice, (int, int, int)) load_fees(slice s) inline {
    var fees = (s~load_grams(), s~load_grams(), s~load_uint(14));
    return (s, fees);
}

(int, int, int, slice, (int, int, int)) load_data() inline_ref {
	var ds = get_data().begin_parse();
	var res = (
		ds~load_uint(32),
		ds~load_uint(256),
		ds~load_grams(),
		ds~load_msg_addr(),
		ds~load_fees()
	);
	ds.end_parse();
	return res;
}

builder store_fees(builder b, (int, int, int) fees) inline {
	var (flat_reward, network_fee, factor) = fees;
	throw_if(391, factor > 10000);

	return b.store_grams(flat_reward)
		.store_grams(network_fee)
		.store_uint(factor, 14);
}

() save_data(int seqno, int public_key, int total_locked, slice collector_addr, (int, int, int) fees) impure inline_ref {
	var st = begin_cell()
		.store_uint(seqno, 32)
		.store_uint(public_key, 256)
		.store_grams(total_locked)
		.store_slice(collector_addr)
		.store_fees(fees)
		.end_cell();
	set_data(st);
}

() recv_internal(slice in_msg) impure {
  ;; do nothing for internal messages
}

() recv_external(slice in_msg) impure {
	slice signature = in_msg~load_bits(512);
	var cs = in_msg;
	int seqno = cs~load_uint(32);

	var (stored_seqno, public_key, total_locked, collector_addr, fees) = load_data();
	throw_unless(33, seqno == stored_seqno);
	throw_unless(34, check_signature(slice_hash(in_msg), signature, public_key));

	accept_message(); ;; message is signed by owner

	int op = cs~load_uint(32);
	if (op == 1) { ;; change collector
		collector_addr = cs~load_msg_addr();
	}
	elseif (op == 2) { ;; change fees
		fees = cs~load_fees();
	}
	elseif (op == 3) { ;; withdraw reward
		;; reserve total_locked + 100 Toncoins for storage fees
		;; raw_reserve(total_locked + 100000000000, 2);

		slice s_addr = cs~load_msg_addr();

		;; #int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddressInt = 0 1 1 0 00
		var msg = begin_cell()
			.store_uint(0x18, 6)
			.store_slice(s_addr)
			.store_grams(0)
			.store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);
		send_raw_message(msg.end_cell(), 128); ;; send all the remainings
	}

	save_data(seqno + 1, public_key, total_locked, collector_addr, fees);
}

;; Get methods

_ get_bridge_data() method_id {
    var (seqno, public_key, total_locked, collector_addr, fees) = load_data();
	var (flat_reward, network_fee, factor) = fees;
	var (wc, addr) = parse_std_addr(collector_addr);
    return (seqno, public_key, total_locked, wc, addr, flat_reward, network_fee, factor);
}
